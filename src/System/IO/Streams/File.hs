{-# LANGUAGE CPP #-}

module System.IO.Streams.File
  ( withFileAsInput
  , withFileAsInputStartingAt
  , unsafeWithFileAsInputStartingAt
  , withFileAsOutput
  ) where

------------------------------------------------------------------------------
import           Control.Exception          (bracket)
import           Control.Monad              (liftM, unless, void)
import           Data.ByteString            (ByteString)
import qualified Data.ByteString            as S
import           Data.Int                   (Int64)
import           System.IO
------------------------------------------------------------------------------
import           System.IO.Streams.Internal

#ifndef PORTABLE
import qualified Data.ByteString.Internal   as S
import qualified Data.ByteString.Unsafe     as S
import           Foreign.Ptr
import           GHC.ForeignPtr
import           System.IO.Posix.MMap
import           System.Posix.Files
import           System.Posix.IO
import           System.Posix.Types
#else
import           System.IO.Streams.Handle
#endif


------------------------------------------------------------------------------
withFileAsInput :: FilePath                          -- ^ file to open
                -> (InputStream ByteString -> IO a)  -- ^ function to run
                -> IO a
withFileAsInput = withFileAsInputStartingAt 0


------------------------------------------------------------------------------
withFileAsInputStartingAt
    :: Int64                             -- ^ starting index to seek to
    -> FilePath                          -- ^ file to open
    -> (InputStream ByteString -> IO a)  -- ^ function to run
    -> IO a


------------------------------------------------------------------------------
-- | Like 'withFileAsInputStartingAt', except that the bytestring emitted by
-- the created 'InputStream' may reuse its buffer. You may only use this
-- function if you do not retain references to the generated bytestrings
-- emitted.
unsafeWithFileAsInputStartingAt
    :: Int64                             -- ^ starting index to seek to
    -> FilePath                          -- ^ file to open
    -> (InputStream ByteString -> IO a)  -- ^ function to run
    -> IO a


------------------------------------------------------------------------------
withFileAsOutput
    :: FilePath                           -- ^ file to open
    -> IOMode                             -- ^ mode to write in
    -> (OutputStream ByteString -> IO a)  -- ^ function to run
    -> IO a


#ifdef PORTABLE
------------------------------------------------------------------------------
withFileAsInputStartingAt idx fp m = withBinaryFile fp ReadMode go
  where
    go h = do
        unless (idx == 0) $ hSeek h AbsoluteSeek $ toInteger idx
        handleToInputStream h >>= m


------------------------------------------------------------------------------
unsafeWithFileAsInputStartingAt = withFileAsInputStartingAt


------------------------------------------------------------------------------
withFileAsOutput fp mode m =
    withBinaryFile fp mode ((m =<<) . handleToOutputStream)


#else
------------------------------------------------------------------------------
maxMMapFileSize :: FileOffset
maxMMapFileSize = 10485760   -- 10MB


------------------------------------------------------------------------------
tooBigForMMap :: FilePath -> IO Bool
tooBigForMMap fp = do
    stat <- getFileStatus fp
    return $! fileSize stat > maxMMapFileSize


------------------------------------------------------------------------------
newBuffer :: Int -> IO (IO ByteString)
newBuffer n = return $ do
    buf <- mallocPlainForeignPtrBytes n
    return $! S.fromForeignPtr buf 0 n


------------------------------------------------------------------------------
reuseBuffer :: Int -> IO (IO ByteString)
reuseBuffer n = do
    buf <- mallocPlainForeignPtrBytes n
    return (return $! S.fromForeignPtr buf 0 n)


------------------------------------------------------------------------------
bUFSIZ :: Int
bUFSIZ = 32752


------------------------------------------------------------------------------
withFileAsInputStartingAt =
    withFileAsInputStartingAtInternal (newBuffer bUFSIZ)


------------------------------------------------------------------------------
unsafeWithFileAsInputStartingAt =
    withFileAsInputStartingAtInternal (reuseBuffer bUFSIZ)


------------------------------------------------------------------------------
withFileAsInputStartingAtInternal
    :: IO (IO ByteString)                -- ^ function to make a new bytestring
                                         --   buffer
    -> Int64                             -- ^ starting index to seek to
    -> FilePath                          -- ^ file to open
    -> (InputStream ByteString -> IO a)  -- ^ function to run
    -> IO a
withFileAsInputStartingAtInternal mkBuf idx fp m = do
    tooBig <- tooBigForMMap fp
    if tooBig then useRead else useMMap

  where
    --------------------------------------------------------------------------
    useMMap = do
        s <- liftM (S.drop (fromEnum idx)) $ unsafeMMapFile fp
        sourceToStream (singletonSource s) >>= m

    --------------------------------------------------------------------------
    useRead = bracket open cleanup mkStream

    --------------------------------------------------------------------------
    open = do
        fd <- openFd fp ReadOnly Nothing defaultFileFlags
        unless (idx == 0) $
            void $ fdSeek fd AbsoluteSeek (toEnum . fromEnum $ idx)

        bufAction <- mkBuf
        return (fd, bufAction)

    --------------------------------------------------------------------------
    cleanup (fd, _) = closeFd fd

    --------------------------------------------------------------------------
    mkStream (fd, bufAction) = makeInputStream (go fd bufAction) >>= m

    --------------------------------------------------------------------------
    go fd bufAction = do
        bs <- bufAction
        S.unsafeUseAsCStringLen bs $ \(ptr, len) -> do
            bytesRead <- fdReadBuf fd (castPtr ptr) (toEnum $ fromEnum len)

            if bytesRead <= 0
              then return Nothing
              else return $! Just $! S.take (fromEnum bytesRead) bs


------------------------------------------------------------------------------
withFileAsOutput fp ioMode m = bracket open closeFd mkStream
  where
    fromIOMode ReadMode      = (ReadOnly, defaultFileFlags)
    fromIOMode WriteMode     = (WriteOnly, defaultFileFlags { trunc = True })
    fromIOMode AppendMode    = (WriteOnly, defaultFileFlags { append = True })
    fromIOMode ReadWriteMode = (ReadWrite, defaultFileFlags)

    open = do
        let (openMode, flags) = fromIOMode ioMode
        openFd fp openMode (Just stdFileMode) flags

    mkStream fd = makeOutputStream (go fd) >>= m

    go _ Nothing   = return $! ()
    go fd (Just s) = S.unsafeUseAsCStringLen s $ \(ptr, len) ->
                     writeAll (castPtr ptr) (toEnum len)
      where
        writeAll ptr len | len <= 0 = return $! ()
                         | otherwise = do
            bytesWritten <- fdWriteBuf fd ptr len
            writeAll (plusPtr ptr (fromEnum bytesWritten))
                     (len - bytesWritten)
#endif
